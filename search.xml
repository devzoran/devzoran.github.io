<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ET-FairyGUI 导入 Unity</title>
      <link href="/ET-FairyGUI%E5%AF%BC%E5%85%A5Unity/"/>
      <url>/ET-FairyGUI%E5%AF%BC%E5%85%A5Unity/</url>
      
        <content type="html"><![CDATA[<ul><li><p>FairyGUI 导入 Unity 进行交互</p><ul><li><p>⭐️Transition中添加标签以及在unity中实现回调（Animation中的Event）</p></li><li><p>ListView 的实现</p><ul><li><p>列表属性的条目资源关联，不设置会导致无法加载</p><p><img src="/ET-FairyGUI%E5%AF%BC%E5%85%A5Unity/%E5%88%97%E8%A1%A8%E5%B1%9E%E6%80%A7%E7%9A%84%E6%9D%A1%E7%9B%AE%E8%B5%84%E6%BA%90%E5%85%B3%E8%81%94.jpg?40"></p></li><li><p>FairyGUI 编辑器中可以设置预览，但切记勾选发布时取消，否则运行时也会被渲染</p><p><img src="/ET-FairyGUI%E5%AF%BC%E5%85%A5Unity/%E7%BC%96%E8%BE%91%E5%88%97%E8%A1%A8-%E5%8F%91%E5%B8%83%E6%B8%85%E7%A9%BA.jpg?40"></p></li><li><p>SetVirtual 和 SetVirtualAndLoop 的区别</p></li><li><p>核心设置代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    mainUI = <span class="keyword">this</span>.GetComponent&lt;UIPanel&gt;().ui;</span><br><span class="line">    list = <span class="keyword">this</span>.mainUI.GetChild(<span class="string">&quot;listView&quot;</span>).asList;</span><br><span class="line">    <span class="keyword">this</span>.list.SetVirtual();  <span class="comment">//设置虚拟列表，以实现动态滑动</span></span><br><span class="line">    <span class="keyword">this</span>.list.itemRenderer = RenderListItem;</span><br><span class="line">    <span class="keyword">this</span>.list.numItems = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">RenderListItem</span>(<span class="params"><span class="built_in">int</span> index, GObject obj</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GButton button = obj.asButton;</span><br><span class="line">    button.title = index.ToString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Loader 加载器实现动态加载包资源</p><ul><li><p>确保加载的图片资源在 FairyGUI 中设置为“导出”</p></li><li><p>核心代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GLoader loaderImg = <span class="keyword">this</span>.mainUI.GetChild(<span class="string">&quot;loader&quot;</span>).asLoader;</span><br><span class="line"><span class="comment">// &quot;ui://pkg_demo/res/img_headicon.png&quot; 此处资源绝对路径如左所标志</span></span><br><span class="line"><span class="comment">// 可知 GetItemURL 接口中的参数，resName 不需要考虑相对路径关系</span></span><br><span class="line">loaderImg.url = UIPackage.GetItemURL(<span class="string">&quot;pkg_demo&quot;</span>, <span class="string">&quot;img_headicon&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>QA</p><ul><li><p>FairyGUI 导出后，Unity 是从哪边触发脚本 AutoGen 的？</p></li><li><p>同一个pkg下，如果有多个Panel，PanelId自动生成的枚举只能生成一个？</p></li><li><p>FairyGUI 编辑器中，只发布自己当前编辑点 pkg，如果点击发布全部，会导致工程中触发的FUIAutoGen把所有FUI相关的文件都进行修改</p></li><li><p>FairyGUI编辑器中发布完后，Unity触发脚本FUICodeSpawner.FUICodeSpawn()</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> FairyGUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FairyGUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ET-FairyGUI 基础知识点</title>
      <link href="/ET-FairyGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/ET-FairyGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p><a href="https://fairygui.com/docs/editor/index">【官方教程中心链接】</a></p><ul><li><p><a href="https://fairygui.com/docs/editor/project_settings">【工程默认设置】</a></p></li><li><p><a href="https://fairygui.com/docs/editor/object">【元件概念】</a></p></li><li><p><a href="https://fairygui.com/docs/editor/image">【图片元件】</a></p><ul><li><p>默认显示</p></li><li><p>形状</p></li><li><p>进度条方式</p></li></ul></li><li><p><a href="https://fairygui.com/docs/editor/movieclip">【动画的生成方式】</a></p><ul><li><p>gif生成</p></li><li><p>序列帧图片生成</p></li></ul></li><li><p><a href="https://fairygui.com/docs/editor/text">【文本】</a></p><ul><li><p>Label</p><ul><li><p>自适应内容大小</p></li><li><p>固定宽度换行</p></li></ul></li><li><p>input field</p><ul><li><p>密码的表现设置</p></li><li><p>输入限制（正则表达式）</p></li><li><p>键盘类型（移动端有效）</p></li><li><p>提示文字</p></li></ul></li><li><p>UBB语法</p></li></ul></li><li><p><a href="https://fairygui.com/docs/editor/richtext">【富文本】</a></p><ul><li><p>图文混排</p><ul><li><p>新建位图字体</p><ul><li><p>字体导入位图编辑器字体界面</p><ul><li><p>字符设置</p></li><li><p>默认大小和默认占位大小</p></li><li><p>是否允许动态修改字号或颜色</p></li><li><p>位图字体与富文本元件关联</p></li></ul></li></ul></li></ul></li></ul></li><li><p><a href="https://fairygui.com/docs/editor/component">【组件】</a></p></li><li><p><a href="https://fairygui.com/docs/editor/group">【组】</a></p><ul><li><p>普通组（主要用于FairyGUI编辑模式下进行快速开发编辑）</p><ul><li><p>选中“显示列表”面板中想要组合的元件</p></li><li><p>点击侧边栏“组合”选项生成组合</p></li></ul></li><li><p>高级组（主要用于在游戏运行模式下进行一些动态编辑，类似于ugui的canvas）</p><ul><li><p>基于普通组在组面板中勾选“高级组”toggle</p></li><li><p>布局类型</p><ul><li><p>无</p></li><li><p>水平</p></li><li><p>垂直</p></li><li><p>行距、列距对布局的影响</p></li></ul></li></ul></li></ul></li><li><p>关联（类似ugui的父子级节点关系）</p><ul><li><p>设置元件关联对象</p></li><li><p>关联属性设置（如左-&gt;左&#x2F;左延展-&gt;左&#x2F;设置百分比关联 等）</p></li></ul></li><li><p><a href="https://fairygui.com/docs/editor/loader">【装载器】</a></p><ul><li><p>设置装载器与元件的关联</p></li><li><p>自动大小</p></li><li><p>填充处理</p></li><li><p>对其</p></li><li><p>帧（只对动画生效）</p></li><li><p>填充方法</p></li></ul></li><li><p><a href="https://fairygui.com/docs/editor/controller">【控制器（PageView，PageReact，元宝飘字等）】</a></p><ul><li><p>控制器的创建</p><ul><li>创建面板中“别名”属性</li></ul></li><li><p>控制器的修改</p></li><li><p>为元件添加控制器</p><ul><li>设置元件一些简单动效</li></ul></li></ul></li><li><p><a href="https://fairygui.com/docs/editor/transition">【动效（Animation关键帧信息设置）】</a></p><ul><li><p>动效的创建</p></li><li><p>设置关键帧信息</p><ul><li>关键很懂话Tween设置lerp效果</li></ul></li><li><p>元件轴心的设置</p></li></ul></li><li><p><a href="https://fairygui.com/docs/editor/button">【按钮】</a></p><ul><li><p>创建按钮</p><ul><li><p>图片设置</p></li><li><p>按钮模式</p></li></ul></li></ul></li><li><p><a href="https://fairygui.com/docs/editor/list">【列表】</a></p><ul><li><p>溢出处理（滚动方向）</p></li><li><p>渲染顺序</p></li><li><p>选择模式</p></li><li><p>选择控制</p></li><li><p>分页控制</p></li><li><p>项目资源（相当于loopscrollpage中关联的itemcell）</p></li></ul></li><li><p>滚动条、滑动条、进度条</p><p><a href="https://fairygui.com/docs/editor/progressbar">【进度条】</a></p><p><a href="https://fairygui.com/docs/editor/slider">【滑动条】</a></p><p><a href="https://fairygui.com/docs/editor/scrollbar">【滚动条】</a></p><ul><li><p>滑动条是可以默认滑动的，但是滚动条需要跟其它组件组合使用，比如配合listview进行滚动条组件关联。</p></li><li><p>listview关联滚动条scrollbar的设置</p></li><li><p>scrollbar滑块大小拉伸问题处理</p><ul><li>滚动条设置面板 -&gt; 固定的滚动滑块大小</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> FairyGUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FairyGUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ET-Spine插件</title>
      <link href="/ET-Spine%E6%8F%92%E4%BB%B6/"/>
      <url>/ET-Spine%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p><a href="http://zh.esotericsoftware.com/spine-unity-download#spine-unity-4.1">【Spine-Unity官网插件安装引导教程】</a> </p><blockquote><p>这里用的是spine-unity 4.1</p></blockquote><h5 id="三种实例化skeleton的方法为"><a href="#三种实例化skeleton的方法为" class="headerlink" title="三种实例化skeleton的方法为:"></a>三种实例化skeleton的方法为:</h5><ul><li>SkeletonAnimation: 使用Spine定制的动画和事件系统, 提供最高的可定制性. 渲染使用的是 MeshRenderer, 可以像Unity sprite一样与 SpriteMask 等遮罩进行交互. 在Unity中推荐以这种方式使用Spine skeleton.</li><li>SkeletonGraphic (UI): 与Unity Canvas一起作为UI元素使用. 像内置的Unity UI元素一样渲染并与UI遮罩(如 RectMask2D )交互. 动画和事件行为与 SkeletonAnimation相同.</li><li>SkeletonRenderer: 使用Unity的Mecanim动画和事件系统来启动、mix和过渡动画. 与SkeletonAnimation相比,提供的动画mix和过渡选项较少.当使用 SkeletonMecanim 时, 无法保证动画过渡看起来和Spine Editor中的预览一致.</li></ul><br><h5 id="记录导入插件后demo报错相关处理方式"><a href="#记录导入插件后demo报错相关处理方式" class="headerlink" title="记录导入插件后demo报错相关处理方式"></a>记录导入插件后demo报错相关处理方式</h5><ul><li>Premultiplied Alpha<br><img src="/ET-Spine%E6%8F%92%E4%BB%B6/premultiplied-alpha-export-import.png?40" alt="premultiplied-alpha-export-import"><ul><li>Texture 打包器启用 Premultiply alpha ,</li><li>Unity Texture 设置中禁用 sRGB (Color Texture) 和 Alpha Is Transparency ,</li><li>Unity Material 参数中禁用 Straight Alpha Texture .</li></ul></li><li>Straight Alpha<br><img src="/ET-Spine%E6%8F%92%E4%BB%B6/straight-alpha-export-import.png?40" alt="straight-alpha-export-import"><ul><li>Texture 打包器禁用 Premultiply alpha , 启用 Bleed ,</li><li>Unity Texture 设置启用 sRGB (Color Texture) 和 Alpha Is Transparency ,</li><li>Unity Material 参数中启用 Straight Alpha Texture .</li></ul></li></ul><br><h5 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h5><ul><li><p>Texture 打包器的默认设置是使用 Premultiply alpha. 运行时中的所有Spine着色器也都默认使用 Premultiply alpha 工作流, 其 Straight Alpha Texture 参数都是默认禁用的.</p></li><li><p>在某些情况下你可能需要使用straight alpha工作流. 比如:</p><ul><li>当你使用了 线性色彩空间, 那么就 必须使用straight alpha.</li></ul></li><li><p>在导出时, Spine是在Gamma色彩空间中进行premultiplication的, 因此在导入时转换为线性色彩空间时将导致色彩超限. 当在material里检测到这种设置组合时, 控制台会给你一个警告消息.</p></li><li><p>当你想使用非Spine着色器时.</p><ul><li>一般的着色器默认用于straight alpha的texture, 这将导致图像附件周围出现错误的黑色边框.</li><li>在切换到straight alpha工作流时, 请确保对所有textures和materials进行如上配置. 你可以通过 Project Settings - Player - Other Settings - Color Space来检查或修改当前的颜色空间.</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> ET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ET-EventSystem</title>
      <link href="/ET-EventSystem/"/>
      <url>/ET-EventSystem/</url>
      
        <content type="html"><![CDATA[<h4 id="事件注册"><a href="#事件注册" class="headerlink" title="事件注册"></a>事件注册</h4><ul><li>通过遍历已加载到程序域中的程序集,获得assemblies下所有定义的类型types。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CodeLoader.cs中的代码片段</span></span><br><span class="line">Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();</span><br><span class="line">Dictionary&lt;<span class="built_in">string</span>, Type&gt; types = AssemblyHelper.GetAssemblyTypes(assemblies);</span><br><span class="line">EventSystem.Instance.Add(types);</span><br><span class="line"></span><br><span class="line"><span class="comment">// AssemblyHelper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">AssemblyHelper</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Dictionary&lt;<span class="built_in">string</span>, Type&gt; <span class="title">GetAssemblyTypes</span>(<span class="params"><span class="keyword">params</span> Assembly[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Dictionary&lt;<span class="built_in">string</span>, Type&gt; types = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, Type&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (Assembly ass <span class="keyword">in</span> args)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (Type type <span class="keyword">in</span> ass.GetTypes())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// type.FullName 该类型的完全限定名，包括其命名空间，但不包括程序集</span></span><br><span class="line">                types[type.FullName] = type;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> types;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>EventSystem.Add(Dictionary&lt;string, Type&gt; addTypes)<br>遍历字典addTypes参数，即前面得到的types变量，将所有逻辑中打上不同功能属性标签的type分类存储，<br>其中[EventAttribute]标签存储在名为allEvents的字典中。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EventAttribute eventAttribute = attr <span class="keyword">as</span> EventAttribute;</span><br><span class="line"></span><br><span class="line">Type eventType = obj.Type;</span><br><span class="line"></span><br><span class="line">EventInfo eventInfo = <span class="keyword">new</span>(obj, eventAttribute.SceneType);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.allEvents.ContainsKey(eventType))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.allEvents.Add(eventType, <span class="keyword">new</span> List&lt;EventInfo&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.allEvents[eventType].Add(eventInfo);</span><br></pre></td></tr></table></figure><br></li></ul><h4 id="事件派发"><a href="#事件派发" class="headerlink" title="事件派发"></a>事件派发</h4><p>  事件派发分为Publish和PublishAsync两种，但核心思路其实是一样的。<br>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Publish</span>&lt;<span class="title">T</span>&gt;(<span class="params">Scene scene, T a</span>) <span class="keyword">where</span> T : <span class="keyword">struct</span></span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;EventInfo&gt; iEvents;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.allEvents.TryGetValue(<span class="keyword">typeof</span> (T), <span class="keyword">out</span> iEvents))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SceneType sceneType = scene.SceneType;</span><br><span class="line">    <span class="keyword">foreach</span> (EventInfo eventInfo <span class="keyword">in</span> iEvents)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (sceneType != eventInfo.SceneType &amp;&amp; eventInfo.SceneType != SceneType.None)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!(eventInfo.IEvent <span class="keyword">is</span> AEvent&lt;T&gt; aEvent))</span><br><span class="line">        &#123;</span><br><span class="line">            Log.Error(<span class="string">$&quot;event error: <span class="subst">&#123;eventInfo.IEvent.GetType().Name&#125;</span>&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        aEvent.Handle(scene, a).Coroutine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>Publish逻辑中，通过this.allEvents.TryGetValue(typeof (T), out iEvents)，获得了继承自AEvent<T>的对象集合</T></li><li>遍历对象集合，筛选出满足sceneType和eventType的类型对象进行事件派发</li><li>举个创建客户端场景之后时间派发流程的例子  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ET.Client</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 此处为class对象打上SceneType标签，并集成AEvent明确需要接受的事件类型</span></span><br><span class="line">    [<span class="meta">Event(SceneType.Client)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AfterCreateClientScene_AddComponent</span>: <span class="title">AEvent</span>&lt;<span class="title">EventType.AfterCreateClientScene</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">async</span> ETTask <span class="title">Run</span>(<span class="params">Scene scene, EventType.AfterCreateClientScene args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> fuiEvent = scene.AddComponent&lt;FUIEventComponent&gt;();</span><br><span class="line">            fuiEvent.AddComponent&lt;CDComponent&gt;();</span><br><span class="line">            scene.AddComponent&lt;FUIComponent&gt;();</span><br><span class="line">            <span class="keyword">await</span> ETTask.CompletedTask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ET.Client</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">SceneFactory</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> ETTask&lt;Scene&gt; <span class="title">CreateClientScene</span>(<span class="params"><span class="built_in">int</span> zone, <span class="built_in">string</span> name</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">await</span> ETTask.CompletedTask;</span><br><span class="line">            <span class="comment">// 创建ClientScene时指定SceneType</span></span><br><span class="line">            Scene clientScene = EntitySceneFactory.CreateScene(zone, SceneType.Client, name, ClientSceneManagerComponent.Instance);</span><br><span class="line">            clientScene.AddComponent&lt;CurrentScenesComponent&gt;();</span><br><span class="line">            clientScene.AddComponent&lt;ObjectWait&gt;();</span><br><span class="line">            clientScene.AddComponent&lt;PlayerComponent&gt;();</span><br><span class="line">            <span class="comment">// 创建完ClientScene后派发事件</span></span><br><span class="line">            EventSystem.Instance.Publish(clientScene, <span class="keyword">new</span> EventType.AfterCreateClientScene());</span><br><span class="line">            <span class="keyword">return</span> clientScene;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Scene <span class="title">CreateCurrentScene</span>(<span class="params"><span class="built_in">long</span> id, <span class="built_in">int</span> zone, <span class="built_in">string</span> name, CurrentScenesComponent currentScenesComponent</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Scene currentScene = EntitySceneFactory.CreateScene(id, IdGenerater.Instance.GenerateInstanceId(), zone, SceneType.Current, name, currentScenesComponent);</span><br><span class="line">            currentScenesComponent.Scene = currentScene;</span><br><span class="line">            </span><br><span class="line">            EventSystem.Instance.Publish(currentScene, <span class="keyword">new</span> EventType.AfterCreateCurrentScene());</span><br><span class="line">            <span class="keyword">return</span> currentScene;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> ET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ET-热重载</title>
      <link href="/ET-%E7%83%AD%E9%87%8D%E8%BD%BD/"/>
      <url>/ET-%E7%83%AD%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>CodeLoader.Start()依赖Init.cs中的Start生命周期触发。<br>无论是否启用热重载流程，必不可少的是需要触发游戏Entry流程，CodeLoader.cs中触发代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IStaticMethod start = <span class="keyword">new</span> StaticMethod(<span class="keyword">this</span>.model, <span class="string">&quot;ET.Entry&quot;</span>, <span class="string">&quot;Start&quot;</span>);</span><br><span class="line">start.Run();</span><br></pre></td></tr></table></figure><p>而在CodeLoader.StartAsync()代码中，又对游戏一些必要模块进行了初始化，同时触发相关事件进行Publish：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">async</span> ETTask <span class="title">StartAsync</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    WinPeriod.Init();</span><br><span class="line">    </span><br><span class="line">    MongoHelper.Init();</span><br><span class="line">    ProtobufHelper.Init();</span><br><span class="line">    </span><br><span class="line">    Game.AddSingleton&lt;NetServices&gt;();</span><br><span class="line">    Game.AddSingleton&lt;Root&gt;();</span><br><span class="line">    Game.AddSingleton&lt;CDSystem&gt;();</span><br><span class="line">    <span class="keyword">await</span> Game.AddSingleton&lt;ConfigComponent&gt;().LoadAsync();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> EventSystem.Instance.PublishAsync(Root.Instance.Scene, <span class="keyword">new</span> EventType.EntryEvent1());</span><br><span class="line">    <span class="keyword">await</span> EventSystem.Instance.PublishAsync(Root.Instance.Scene, <span class="keyword">new</span> EventType.EntryEvent2());</span><br><span class="line">    <span class="keyword">await</span> EventSystem.Instance.PublishAsync(Root.Instance.Scene, <span class="keyword">new</span> EventType.EntryEvent3());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ET-资源系统</title>
      <link href="/ET-%E8%B5%84%E6%BA%90%E7%B3%BB%E7%BB%9F/"/>
      <url>/ET-%E8%B5%84%E6%BA%90%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> ET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ET-启动流程</title>
      <link href="/ET-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
      <url>/ET-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<ul><li><p>Init.cs</p><ul><li>Start生命周期<blockquote><p>Game部分单例对象的初始化</p></blockquote><ul><li>新增了YooAsset的资源系统初始化流程，代码如下：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Game.AddSingleton&lt;MonoResComponent&gt;().InitAsync(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Game.AddSingleton&lt;CodeLoader&gt;().Start();</span><br><span class="line">&#125;).Coroutine();</span><br></pre></td></tr></table></figure>资源初始化结束后，再执行CodeLoader.cs中的AOT流程<ul><li><a href="../ET-%E8%B5%84%E6%BA%90%E7%B3%BB%E7%BB%9F/">关于MonoResComponent</a></li><li><a href="../ET-%E7%83%AD%E9%87%8D%E8%BD%BD/">关于CodeLoader</a></li></ul></li></ul></li></ul><br><ul><li>Update生命周期<blockquote><p>Game中Update流程</p></blockquote><ul><li><a href>关于Game.Update()</a></li></ul></li></ul><br><ul><li>LateUpdate生命周期<blockquote><p>Game中的LateUpdate流程和FrameFinishUpdate流程</p></blockquote><ul><li><a href>关于Game.LateUpdate()</a></li><li><a href>关于Game.FrameFinishUpdate()</a></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> ET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ET TODO LIST</title>
      <link href="/ET-TODO-LIST/"/>
      <url>/ET-TODO-LIST/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h4 id="游戏初始化流程"><a href="#游戏初始化流程" class="headerlink" title="游戏初始化流程"></a>游戏初始化流程</h4><h4 id="FGUI"><a href="#FGUI" class="headerlink" title="FGUI"></a>FGUI</h4><pre><code>- 相关组件功能实现界面demo    - 富文本    - 按钮事件    - toggle    - listview    - pageview- 游戏主界面- 聊天</code></pre><h4 id="引导"><a href="#引导" class="headerlink" title="引导"></a>引导</h4><h4 id="Spine"><a href="#Spine" class="headerlink" title="Spine"></a>Spine</h4><h4 id="战斗"><a href="#战斗" class="headerlink" title="战斗"></a>战斗</h4><h4 id="红点"><a href="#红点" class="headerlink" title="红点"></a>红点</h4><h4 id="UI动画"><a href="#UI动画" class="headerlink" title="UI动画"></a>UI动画</h4><h4 id="Audio"><a href="#Audio" class="headerlink" title="Audio"></a>Audio</h4><h4 id="AOT流程研究总结"><a href="#AOT流程研究总结" class="headerlink" title="AOT流程研究总结"></a>AOT流程研究总结</h4><h4 id="Hotfix"><a href="#Hotfix" class="headerlink" title="Hotfix"></a>Hotfix</h4><h4 id="YooAsset"><a href="#YooAsset" class="headerlink" title="YooAsset"></a>YooAsset</h4><hr><h4 id="hexo启用其它端口命令"><a href="#hexo启用其它端口命令" class="headerlink" title="hexo启用其它端口命令"></a>hexo启用其它端口命令</h4><pre><code>hexo server -p 7777</code></pre>]]></content>
      
      
      <categories>
          
          <category> ET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity中的AOT和JIT</title>
      <link href="/Unity%E4%B8%AD%E7%9A%84AOT%E5%92%8CJIT/"/>
      <url>/Unity%E4%B8%AD%E7%9A%84AOT%E5%92%8CJIT/</url>
      
        <content type="html"><![CDATA[<h4 id="JIT"><a href="#JIT" class="headerlink" title="JIT"></a>JIT</h4><pre><code>JIT，即Just-in-time,动态(即时)编译，边运行边编译</code></pre><ul><li>JIT 的优点<ul><li>可以根据当前硬件情况实时编译生成最优机器指令（ps. AOT也可以做到，在用户使用时使用字节码根据机器情况再做一次编译）</li><li>可以根据当前程序的运行情况生成最优的机器指令序列</li><li>当程序需要支持动态链接时，只能使用JIT</li><li>可以根据进程中内存的实际情况调整代码，使内存能够更充分的利用</li></ul></li><li>JIT 的缺点<ul><li>编译需要占用运行时资源，会导致进程卡顿</li><li>由于编译时间需要占用运行时间，对于某些代码的编译优化不能完全支持，需要在程序流畅和编译时间之间做权衡</li><li>在编译准备和识别频繁使用的方法需要占用时间，使得初始编译不能达到最高性能</li></ul></li></ul><h4 id="AOT"><a href="#AOT" class="headerlink" title="AOT"></a>AOT</h4><pre><code>Ahead Of Time，指运行前编译，是两种程序的编译方式</code></pre><ul><li>AOT 的优点<ul><li>在程序运行前编译，可以避免在运行时的编译性能消耗和内存消耗</li><li>可以在程序运行初期就达到最高性能</li><li>可以显著的加快程序的启动</li></ul></li><li>AOT 的缺点<ul><li>在程序运行前编译会使程序安装的时间增加</li><li>牺牲语言的一致性</li><li>将提前编译的内容保存会占用更多的外存</li></ul></li></ul><h4 id="与Unity的关联"><a href="#与Unity的关联" class="headerlink" title="与Unity的关联"></a>与Unity的关联</h4><ul><li>JIT &amp; Mono 编译<br>Unity 的跨平台技术是通过一个 Mono 虚拟机实现的。而这个虚拟机更新太慢，不能很好地适应众多的平台。<br><img src="/Unity%E4%B8%AD%E7%9A%84AOT%E5%92%8CJIT/MONOVM.jpg?40" alt="mono vm"></li><li>AOT &amp; IL2CPP编译<br>unity 公司因为 Mono 的缺点自行研发了 IL2cpp，把本来应该在 mono 虚拟机上跑的中间代码转换成 cpp 代码，再利用 c++ 的跨平台特性(在各个平台上通过对各平台都有良好优化的 native c++ 编译器编译)，以获得更高的效率和更好的兼容性。<br><img src="/Unity%E4%B8%AD%E7%9A%84AOT%E5%92%8CJIT/IL2CPPVM.jpg?40" alt="il2cpp vm"></li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 安装 Node.js</title>
      <link href="/Mac%E5%AE%89%E8%A3%85nodejs/"/>
      <url>/Mac%E5%AE%89%E8%A3%85nodejs/</url>
      
        <content type="html"><![CDATA[<h4 id="通过-nvm-安装指定版本的-node"><a href="#通过-nvm-安装指定版本的-node" class="headerlink" title="通过 nvm 安装指定版本的 node"></a>通过 nvm 安装指定版本的 node</h4><ul><li><p>安装 NVM（前提是你安装了homebrew）</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install nvm</span><br></pre></td></tr></table></figure></li><li><p>在 shell 中可以使用 nvm 命令，如果没有 .bash_profile 文件需要自行 touch .bash_profile</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~ </span><br><span class="line">$ vim .bash_profile </span><br></pre></td></tr></table></figure></li><li><p>i 键进入编辑模式，在最后另起一行添加以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export NVM_DIR=~/.nvm</span><br><span class="line">source $(brew --prefix nvm)/nvm.sh</span><br></pre></td></tr></table></figure></li><li><p>esc 退出编辑模式</p></li><li><p>:wq! 退出并保存修改</p></li><li><p>重新 source</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ source .bash_profile</span><br></pre></td></tr></table></figure></li></ul><h4 id="使用-nvm-安装-node"><a href="#使用-nvm-安装-node" class="headerlink" title="使用 nvm 安装 node"></a>使用 nvm 安装 node</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ nvm ls-remote 联网查看 所有的node可用版本</span><br><span class="line"></span><br><span class="line">$ nvm install xxx 下载你想要的版本</span><br><span class="line"></span><br><span class="line">$ nvm use xxx 使用指定版本的node </span><br><span class="line"></span><br><span class="line">$ nvm alias default xxx 每次启动终端都使用该版本的node </span><br></pre></td></tr></table></figure><h4 id="检测是否安装完成"><a href="#检测是否安装完成" class="headerlink" title="检测是否安装完成"></a>检测是否安装完成</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">$ npm -v</span><br></pre></td></tr></table></figure><h4 id="zsh-command-not-found"><a href="#zsh-command-not-found" class="headerlink" title="zsh: command not found"></a>zsh: command not found</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 终端执行</span><br><span class="line">vim ~/.zshrc</span><br><span class="line"># 最后一行添加命令</span><br><span class="line">source ~/.bash_profile</span><br><span class="line"># 编辑退出后，控制台执行</span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac安装Homebrew</title>
      <link href="/Mac%E5%AE%89%E8%A3%85Homebrew/"/>
      <url>/Mac%E5%AE%89%E8%A3%85Homebrew/</url>
      
        <content type="html"><![CDATA[<h4 id="brew-简介"><a href="#brew-简介" class="headerlink" title="brew 简介"></a>brew 简介</h4><p>  brew 又叫 <strong>Homebrew</strong>，是 Mac OSX 上的软件包管理工具，能在 Mac 中方便的安装软件或者卸载软件， 只需要一个命令， 非常方便。</p><h4 id="安装-brew"><a href="#安装-brew" class="headerlink" title="安装 brew"></a>安装 brew</h4><p>  brew 的官方网站： <a href="http://brew.sh/">http://brew.sh/</a>   在官方网站对brew的用法进行了详细的描述</p><h4 id="安装方法："><a href="#安装方法：" class="headerlink" title="安装方法："></a>安装方法：</h4><p>  在 Mac 中打开 Termal 并输入命令：<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -e &quot;$(curl -fsSL https://raw.github.com/mxcl/homebrew/go)” </span><br></pre></td></tr></table></figure><br>  注：此链接可能会根据官网变动</p><h4 id="使用-brew-安装软件举例"><a href="#使用-brew-安装软件举例" class="headerlink" title="使用 brew 安装软件举例"></a>使用 brew 安装软件举例</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 安装 git</span><br><span class="line">brew install git</span><br></pre></td></tr></table></figure>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 安装 wget</span><br><span class="line">brew install wget</span><br></pre></td></tr></table></figure><h4 id="使用-brew-卸载软件"><a href="#使用-brew-卸载软件" class="headerlink" title="使用 brew 卸载软件"></a>使用 brew 卸载软件</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew uninstall wget</span><br></pre></td></tr></table></figure><h4 id="使用-brew-查询软件"><a href="#使用-brew-查询软件" class="headerlink" title="使用 brew 查询软件"></a>使用 brew 查询软件</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew search /wge*/</span><br></pre></td></tr></table></figure><p>  &#x2F;wge*&#x2F;是个正则表达式， 需要包含在&#x2F;中</p><h4 id="其他-brew-命令"><a href="#其他-brew-命令" class="headerlink" title="其他 brew 命令"></a>其他 brew 命令</h4><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>brew list</td><td>列出已安装的软件</td></tr><tr><td>brew update</td><td>更新brew</td></tr><tr><td>brew home</td><td>用浏览器打开brew的官方网站</td></tr><tr><td>brew info</td><td>显示软件信息</td></tr><tr><td>brew deps</td><td>显示包依赖</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Homebrew </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Homebrew </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
